=========================
はじめてみよう
=========================
Elasticsearchは、高いケーラビリティを持つオープンソースの全文検索解析のエンジンである。

ほぼリアルタイムで、すばやく大きなボリュームのデータを蓄積、検索、解析してくれる。
一般的に、複雑な検索機能と要求をもつ強力なアプリケーションの基礎となるエンジン／技術として使われている。

ここで、Elasticsearchが使われるいくつかのサンプルケースを紹介する.

... skip ... あとで書く


---------------------------------------
基本コンセプト
---------------------------------------
Elasticsearchの核となるコンセプトはいくつかあって、最初からこのコンセプトを理解しておくことは、学習プロセスを容易なものにしてくれるだろう。

ほぼリアルタイム(NRT:Near Real Time)
==============================================
Elasticsearchは、ほぼリアルタイムな検索プラットフォームである。
これが意味することは、ドキュメントをインデックスにする時間から、検索可能になるまでがわずかな遅延（通常、1秒程度）であるということである。

Cluster（クラスター）
==============================================
クラスターは、1つ以上のNode（サーバ）の集合であり、全体のデータを保持して、すべてのノードを横断した検索能力と連合したインデキシングを提供する。
クラスターは、ユニークな名前で識別され、デフォルトでは"elasticsearch"である。

異なる環境で同じクラスタ名を再利用しないことを確認してください。さもないと、間違ったクラスターに参加してしまうかもしれない。
例えば、開発用、ステージング用、商用のクラスタに、logging-dev、logging-stage、logging-prodを使うことができる。

その中に、1つのノードだけを持つクラスタがあることは、適正である。
さらに、独自のユニークなクラスタ名をそれぞれ持つ複数の独立したクラスターを持つかもしれない。

Node（ノード）
==============================================
ノードは、クラスターの一部となる１つのサーバーのことであり、データを保存したり、クラスタのインデキシングや検索に参加したりする。
クラスタと同様に、ノードは名前で識別される。デフォルトでは、ランダムなUUID(Universally Unique IDentifier)であり、開始時に割り当てられる。
もちろん、付けたい名前を定義することもできる。ノード名は、クラスター内のノードを識別するという管理目的として、とても重要である。

ノードは、特定のクラスタに参加するように設定される。
デフォルトでは、各ノードは elastcisearch と名付けられたクラスターに参加するように設定されている。
ノードはお互いに発見することができるので、自動的に形成して、クラスタに参加する。

１つのクラスターでは、多くノードを持つことができる。
さらに、ネットワーク上で現在実行中の他のElastic nodeがない場合に、シングルノードで開始する。デフォルトでは、elasticsearchという１つのノードを持つクラスターが形成される。

Index（インデックス）
==============================================
インデックスは、ある程度同様の特性を持つドキュメントの集合である。
例えば、カスタマーデータのためのインデックスや、プロダクトカタログのためのインデックス、注文データのためのインデックスを持つことができる。
インデックスもまた名前で識別される（すべて小文字であること！！）。
そして、この名前は、インデックスの中にあるドキュメントに対して、インデキシングや検索、更新、削除操作を実行する際に、インデックスへの参照に使われる。

Tpye（タイプ）
==============================================

.. warning::

   Deprecated in 6.0.0

インデックスの論理的なカテゴリ/パーティションに使われるTypeは、同じインデックス内に異なる種類のドキュメントを格納する。
例えば、１つのタイプはユーザー、もう１つのタイプはブログ記事とか。
インデックス内に複数の種類を作成することはもはや不可能である。Typeの全体のコンセプトは、最新バージョンで削除されるだろう。

Document（ドキュメント）
==============================================
Documentは、インデックスされる情報の基本的な単位である。
例えば、一人のカスタマーのドキュメントを持つことができる。他のドキュメントには１つの商品を、またもう１つのドキュメントには１つの注文を、といった具合に。
そして、このDocumentは、JSONで表現される。

Index/Typeとともに、多くのドキュメントを保存できる。


Shareds & Replicas（シャードとレプリカ）
==============================================
インデックスは、潜在的に、１つのノードのハードウェア限界を超えることができる大量のデータを保存できる。
例えば、ディスク領域の1TBを取る10億ものドキュメントをもつ１つのインデックスは、
１つのノードのディスクには適さないかもしれないし、また１つのノードだけで検索リクエストを処理するには遅すぎるかもしれない。

この問題を解決するために、Elastcisearchはインデックスを複数のピースに分割する機能を提供していて、これはシゃードと呼ばれる。
インデックスを作るときに、シャードの数を簡単に定義することができる。
各シャードは、完全な機能を有していて、クラスター内のどのノードにもホストされる独立したインデックスである。

Sharding（シャーディング）は、主に２つの理由で重要である。

* コンテンツ量を水平に分けたり、スケールしたりする。
* 性能やスループットをあげるように、シャードを横断して操作を分散させたり、並列にさせたりする。

シャードがどのように分散されるのか、ドキュメントが検索リクエストの裏でどのように集計されるのかのメカニックは、
完全にElasticsearchで管理されていて、ユーザとしてのあなたにとって明白である。

失敗が常に予期されるネットワーク／クラウド環境では、シャードやノードがとにかくオフラインだったり、何らかの理由で
消えたりするケースにおいて、フェールオーバー・メカニズムを持つことは、とても有用であり、強く推奨される。

これを終割に対して、Elasticsearchは、インデックスのシャードの１つ以上のコピーを作らせる。これはレプリカシャードと呼ばれ、
短縮してレプリカと呼ぶ。

レプリケーション（複製）は主に２つの理由で重要である。

* シャードとノードが失敗するケースで、高いアベイラビリティを提供する。
  この理由として、orignal/primaryのシャードがコピーされるときに、レプリカシャードは同じノードに決して割り当てられない
  ことが重要である。
* 検索は、並列にすべてのレプリカに対して実行されるので、検索のボリュームやスループットをスケールアウトさせる。

要約のために各インデックスは複数のシャードに分割される。
インデックスはゼロ（＝no replicas）か、それ以上複製される。
一度複製されると、各インデックスはプライマリ・シャード（複製されたオリジナルのシャード）と
レプリカ・シャード（プライマリ・シャードのコピー）を持つ。
シャードとレプリカの数は、インデックス生成時に、インデックスごとに定義される。インデックスが作られた後、
動的にレプリカの数を変更するかもしれないが、事後のシャードの数を変えることはできない。

デフォルトで、各インデックスは５つのプライマリ・シャードと１つのレプリカが割り当てられる。

.. admonition:: 要件
   :class: note

   各Elasticsearchのシャードは、Luceneインデックスである。
   １つのLuceneインデックスで持っているドキュメントの最大数である。
   LUCENE-5843のように、リミットは 2,145,483,519 (=Integer.MAX_VALUE - 128) ドキュメント。
   _catshareds APIを使えば、シャードサイズをモニタリングできる。



---------------------------------------
インストール
---------------------------------------
Elasticsearchは、少なくとも Java8 を要求する。
とくにここで書いているように、Oracle JDKのバージョン 1.8.0_131を使うことを推奨する。
まずは、Javaのバージョンを確認しておくように。




tar でインストールする例
==============================================
あるということである。

.. code-block:: console

   # curl -L -O https://artifacts.elastic.co/donwloads/elasticsearch/elasticsearch-6.2.3.tar.gz
   # tar -xvf elasticsearch-6.2.3.tar.gz
   # cd elasticsearch-6.2.3/bin
   # ./elasticsearch



---------------------------------------
クラスタの探検
---------------------------------------


---------------------------------------
データの変更
---------------------------------------


---------------------------------------
データの探検
---------------------------------------



---------------------------------------
終わりに
---------------------------------------
